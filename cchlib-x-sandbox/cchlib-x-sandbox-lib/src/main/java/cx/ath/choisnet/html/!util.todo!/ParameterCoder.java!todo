/*
** $VER: ParameterCoder.java
*/
package jrpdk.servlet.htmlGenerator.util;

// import commun.util.Format.Hexa;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

/**
** Classe destinée à en encoder et décoder les paramètres.
**
** <PRE>
** <B>Exemple:</B>
**  ParameterCoder p = new ParameterCoder( new Hexa( 0xDEADBEEFL ) );
**
**  String encode = p.encode( DATAS );
**
**  ... TRAITEMENT / RETOUR DU NAVIGATEUR ...
**
**  String decode = p.decode( encode );
**
**  System.out.println( "original = " + DATAS  );
**  System.out.println( "encode " + encode );
**  System.out.println( "decode " + decode );
** </PRE>
**
** <B>Algorithme d'encodage :</B><BR>
** (Les lettres des digits HEXA sont des majuscules)
** <PRE>
** 1. Encode la clé magique sous forme de 4 digits codé
**    en héxa.
**
** 2. Initialise la chaîne 'résultat intermédiaire' à vide.
**
** 3. Pour chaque caractère (position i) :
**   - Récupère la valeur ASCII du caractère.
**   - Fait un XOR avec la valeur ASCII du (i modulo 4)ème
**     caractère  de la clé magique
**   - Encode cette valeur en héxa sur 2 digits pour obtenir
**     une chaîne 'résultat partiel'.
**   - Ajoute la chaîne 'résultat partiel' en fin de la chaîne
**     'résultat intermédiaire'
**
** 4. Calcul le CRC de la chaîne non codée, encode le
**    CRC en hexa (4 digits).
**
** 5. Le résultat final est la chaîne CRC sur 4 digits
**    suivie de la chaîne 'résultat intermédiaire'
** </PRE>
**
** <PRE>
**  1.00 2000.10.09 Version initiale
** </PRE>
**
** @author Claude CHOISNET
** @version 1.00 09/10/2000
*/
public class ParameterCoder
{
/** 32 Bits default key */
protected final static String MAGIC_KEY = "0xA5A5A5A5";

/** Nombre d'octects de la chaîne CRC */
protected final static int CRC_LENGTH = 8;

/** Clé actuelle sur 4 octects*/
protected byte magicKeyValue[];

/**
** Initialisation de l'encodeur à l'aide de la clé par défaut.
*/
public ParameterCoder() // ------------------------------------------------
{
// this( new Hexa( MAGIC_KEY ) );
}

///**
//**
//**
//** @param magicKey  Nombre entier sur 32 bits (4 octects), correspondant à la
//**                  clé d'encodage.
//*/
//public ParameterCoder( Hexa magicKey ) // ---------------------------------
//{
// // passe la clé sous forme de 4 digits codé en héxa.
// this.magicKeyValue = magicKey.toByte();
//}

/**
** Encode une chaîne
**
** @param str String à encoder
**
** @return la chaîne encodée
*/
public String encode( String str ) // -------------------------------------
{
 byte[]         valueBytes  = str.getBytes();
 StringBuffer   result      = new StringBuffer();

 int keyIndex   = 0;
 int keyMax     = magicKeyValue.length;

 //
 // Pour chaque caractères :
 //     - Récupère la valeur ASCII du caractère.
 //     - Fait un XOR avec la valeur ASCII du ième caractère modulo 4
 //       de la clé magique
 //     - Encode le résultat en héxa sur 2 digits
 //
// for( int i = 0; i < str.length(); i++ ) {
//    result.append(
//        Hexa.encode(
//            (byte)( valueBytes[ i ] ^ magicKeyValue[ keyIndex ] )
//            )
//        );
//    keyIndex = (++keyIndex) % keyMax;
//    }

 // Calcul le CRC de la chaîne non codée,
 // puis retourne une chaîne contenant le CRC codé en
 // HEXA sur 4 caractères suivit de la chaîne encodée.
 return getHexChecksum( str ) + result.toString();
}

/**
** Encode une chaîne
**
** @param str String à décoder
** @return la chaîne décodée
** @exception ParameterCoderException en cas de problème lors du
**            décodage.
*/
public String decode( String str ) throws ParameterCoderException // ------
{
 if( str == null ) {
    throw new ParameterCoderException( "decode( null )" );
    }

 // récupère le CRC
 String crc;

 try {
    // Isole le CRC
    crc = str.substring( 0, CRC_LENGTH );
    // retire le CRC
    str  = str.substring( CRC_LENGTH );
    }
 catch( StringIndexOutOfBoundsException rename ) {
    throw new ParameterCoderException( rename.toString() );
    }

 // Vérifie le taille des données
 int len = str.length();

 if( (len % 1) != 0 ) {
    throw new ParameterCoderException( "Bad size" );
    }

 int    size        = len >> 1;
 byte[] valueBytes  = new byte[ size];
 int    keyIndex    = 0;
 int    keyMax      = magicKeyValue.length;

 try {
    //
    // Récupère la valeur du digit codé hexa et decode l'octect
    //
//    for( int i = 0; i < size; i++) {
//        int index = i << 1;
//
//        valueBytes[ i ] =
//            (byte)(
//                Hexa.decodeToByte( str.substring( index, index + 2 ) )
//                ^
//                magicKeyValue[ keyIndex ]
//                );
//
//        keyIndex = (++keyIndex) % keyMax;
//        }
    }
 catch( NumberFormatException rename ) {
    throw new ParameterCoderException( rename.toString() );
    }

 String result = new String( valueBytes );

 // Calcul le CRC
 String crcNew = getHexChecksum( result );

 // Verification du CRC
 if( ! crc.equals( crcNew ) ) {
    System.err.println( "throw new  ParameterCoderException( 'CRC Error' )" );
    System.err.println( "crcNew " + crcNew );
    System.err.println( "crc    " + crc );

    throw new  ParameterCoderException( "CRC Error" );
    }

 return result;
}

/**
** Calcul le checksum d'une chaîne et le retourne sous forme d'entier.
*/
public static long getLongChecksum( String datas ) // ---------------------
{
 Checksum   checksum    = new CRC32();
 byte[]     bytes       = datas.getBytes();
 int        len         = bytes.length;

 checksum.update( bytes, 0, len);

 return checksum.getValue();
}

/**
** Calcul le checksum d'une chaîne et le retourne sous de cahîne codée
** en HEXA sur 4 digits
*/
public static String getHexChecksum( String datas ) // --------------------
{
// return Hexa.encode( getLongChecksum( datas ), CRC_LENGTH );
 return null;
}

} // class

