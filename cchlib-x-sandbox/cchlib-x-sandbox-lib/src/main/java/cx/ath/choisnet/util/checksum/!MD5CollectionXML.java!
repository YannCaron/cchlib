/*
** -----------------------------------------------------------------------
** Nom           : cx/ath/choisnet/util/checksum/MD5CollectionXML.java
** Description   :
** Encodage      : ANSI
**
**  3.01.001 2006.02.15 Claude CHOISNET - Version initiale
**  3.01.042 2006.05.24 Claude CHOISNET
**                      Reprise de la documentation.
**                      Mise en cache du nombre d'éléments.
**
** -----------------------------------------------------------------------
**
** cx.ath.choisnet.util.checksum.MD5CollectionXML
**
*/
package cx.ath.choisnet.util.checksum;

import cx.ath.choisnet.xml.XMLParser;
import java.io.File;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
** <p>
** Classe permettant de constuire des flux XML à partir d'un objet {@link MD5Collection}
** et réciproquement.
** </p>
**
** @author Claude CHOISNET
** @since   3.01.001
** @version 3.01.042
**
** @see MD5Tree
** @see DuplicateLayer
** @deprecated use {@link cx.ath.choisnet.util.duplicate.MD5CollectionXMLException} instead
*/
@Deprecated
public class MD5CollectionXML
    implements MD5Collection
{
/** serialVersionUID */
private static final long serialVersionUID = 2L;

/**
** Liste des objets File correspondant aux dossiers
*/
protected SortedSet<File> dbFoldersFile;

/**
** Couple (empreinte, liste de File fichiers)
*/
protected SortedMap<MD5TreeEntry,SortedSet<File>> dbMessageDigest;

/**
** Mise en cache du nombre de fichiers.
*/
private transient int _transient_filesCount = 0;

/**
** Nom de l'élément racine du document XML
*/
public final static String ROOT_ELEMENT_NAME
    = "cx.ath.choisnet.util.checksum.MD5CollectionXML";

/**
** Construction d'un MD5CollectionXML vide
*/
private MD5CollectionXML() // ---------------------------------------------
{
 this.dbMessageDigest   = new TreeMap<MD5TreeEntry,SortedSet<File>>();
 this.dbFoldersFile     = new TreeSet<File>();
}

/**
** Construction d'un MD5CollectionXML vide
*/
public MD5CollectionXML( // -----------------------------------------------
    final Document document
    )
    throws MD5CollectionXMLException
{
 this();

 final Element rootElement = document.getDocumentElement();

 if( ! rootElement.getTagName().equals( ROOT_ELEMENT_NAME ) ) {
    //
    // Prob. d'initialisation...
    //
    throw new MD5CollectionXMLException( "Élément inattendu '" + rootElement.getTagName() + "'" );
    }

 loadFolders( rootElement.getElementsByTagName( "folders" ) );
 loadFiles( rootElement.getElementsByTagName( "files" ) );
}

/**
** Construction d'un MD5CollectionXML vide
*/
public MD5CollectionXML( // -----------------------------------------------
    final XMLParser xmlParser
    )
    throws MD5CollectionXMLException
{
 this( xmlParser.getDocument() );
}

/**
** La liste des fichiers sous forme d'un object Map contenant un couple
** formé de l'empreinte du fichier et d'un ensemble d'objects File (1+)
** correspondant à ces représentants.
**
** @return un Map<MD5TreeEntry,? extends Set<File>>
*/
public Map<MD5TreeEntry,? extends Set<File>> files() // -------------------
{
 return this.dbMessageDigest;
}

/**
** Liste des objets File correspondant aux dossiers
*/
public Set<File> folders() // ---------------------------------------------
{
 return this.dbFoldersFile;
}

/**
** Retrouve un ensemble de fichier à partir de leur empreinte.
**
** @param md5 Empreinte recherchée
**
** @return un Set<File> si au moins un fichier correspond au MD5TreeEntry
** donné, retourne null sinon.
*/
public Set<File> getFiles( final MD5TreeEntry md5 ) // --------------------
{
 return this.dbMessageDigest.get( md5 );
}

/**
** Retourne le nombre de fichiers contenu dans la collection.
**
** @return un int correspondant au nombre de fichiers (hors dossier) étant
**         défini dans la collection.
*/
public int filesCount() // ------------------------------------------------
{
 if( this._transient_filesCount == 0 ) {
    _transient_filesCount = MD5CollectionHelper.filesCount( this );
    }

 return _transient_filesCount;
}

/**
** Compares this object with the specified object for order. Returns a
** negative integer, zero, or a positive integer as this object is less
** than, equal to, or greater than the specified object.
*/
public int compareTo( final MD5Collection anOtherMD5Collection ) // -------
{
 if( super.equals( anOtherMD5Collection ) ) {
    return 0; // on s'arrête là, c'est le même objet !
    }

 return MD5CollectionHelper.compare( this, anOtherMD5Collection );
}

/**
** Indicates whether some other {@link MD5Collection} is "equal to" this one.
**
*/
public boolean equals( final MD5Collection anOtherMD5Collection ) // ------
{
 if( super.equals( anOtherMD5Collection ) ) {
    return true; // on s'arrête là, c'est le même objet !
    }

 return MD5CollectionHelper.compare( this, anOtherMD5Collection ) == 0;
}

/**
** Sauvegarde l'objet dans un flux sous forme de XML.
**
** @param output Objet {@link Appendable} destiné à recevoir le flux XML.
**
** @throws java.io.IOException en cas de problème lors de l'ajout dans le flux.
**
** @see #toXML(MD5Collection,Appendable)
*/
public void toXML( final Appendable output ) // ---------------------------
    throws java.io.IOException
{
 toXML( this, output );
}

/**
**
**
**
*/
private void loadFolders( final NodeList foldersNodeList ) // -------------
    throws MD5CollectionXMLException
{
 final int len = foldersNodeList.getLength();

 if( len > 1 ) {
    throw new MD5CollectionXMLException( "to much folders Elements:" + len );
    }
 else if( len == 1 ) {
    final NodeList  nodeList= ((Element)foldersNodeList.item( 0 )).getElementsByTagName( "folder" );
    final int       max     = nodeList.getLength();

    for( int i = 0; i < max; i++ ) {
        final Node node = nodeList.item( i );

        if( node instanceof Element ) {
            // System.out.println( "node: " + node + " - " + node.getTextContent() );
            this.dbFoldersFile.add( new File( node.getTextContent() ) );
            }
        }
    }
}

/**
**
**
**
*/
private void loadFiles( final NodeList filesNodeList ) // -----------------
    throws MD5CollectionXMLException
{
 final int len = filesNodeList.getLength();

 if( len > 1 ) {
    throw new MD5CollectionXMLException( "to much files Elements:" + len );
    }
 else if( len == 1 ) {
    final NodeList  nodeList= ((Element)filesNodeList.item( 0 )).getElementsByTagName( "entry" );
    final int       max     = nodeList.getLength();

    for( int i = 0; i < max; i++ ) {
        final Node node = nodeList.item( i );

        if( node instanceof Element ) {
            final Element       element = ((Element)node);
            final MD5TreeEntry  md5     = MD5TreeEntry.newInstance( element.getAttribute( "id" ) );

            this.dbMessageDigest.put(
                    md5,
                    buildFilesSet( element.getElementsByTagName( "file" ) )
                    );
            }
        }
    }
}

/**
**
**
**
*/
private static SortedSet<File> buildFilesSet( final NodeList nodeList ) // ------
{
 final int              max     = nodeList.getLength();
 final SortedSet<File>  list    = new TreeSet<File>();

 for( int i = 0; i < max; i++ ) {
    final Node node = nodeList.item( i );

    if( node instanceof Element ) {
        list.add( new File( node.getTextContent() ) );
        }
    }

 return list;
}

/**
** Sauvegarde d'un objet {@link MD5Collection} dans un flux sous forme de XML.
**
** @param aMD5Collection    Objet {@link MD5Collection} à transformer en XML.
** @param output            Objet {@link Appendable} destiné à recevoir le flux XML.
**
** @throws java.io.IOException en cas de problème lors de l'ajout dans le flux.
*/
public static void toXML( // ----------------------------------------------
    final MD5Collection aMD5Collection,
    final Appendable    output
    )
    throws java.io.IOException
{
 output.append( "<" + ROOT_ELEMENT_NAME + ">\n" );
 output.append( " <folders>\n" );

 for( File folder : aMD5Collection.folders() ) {
    output.append( "  <folder>" + folder.getPath() + "</folder>\n" );
    }

 output.append( " </folders>\n" );
 output.append( " <files>\n" );

 for( Map.Entry<MD5TreeEntry,? extends Set<File>> entry : aMD5Collection.files().entrySet() ) {
    output.append( "  <entry id=\"" + entry.getKey() + "\">\n" );

    for( File f : entry.getValue() ) {
        output.append( "    <file>" + f.getPath() + "</file>\n" );
        }

    output.append( "  </entry>\n" );
    }

 output.append( " </files>\n" );
 output.append( "</" + ROOT_ELEMENT_NAME + ">\n" );
}

/**
** Transformation d'un objet {@link MD5Collection} en une chaîne sous forme de XML.
**
** @param aMD5Collection Objet {@link MD5Collection} à transformer en XML.
*/
public static String toXML( final MD5Collection aMD5Collection ) // --------
{
 final StringBuilder sb = new StringBuilder();

 try {
    MD5CollectionXML.toXML( aMD5Collection, sb );
    }
  catch( java.io.IOException unexpected ) {
    throw new RuntimeException( unexpected );
    }

 return sb.toString();
}

/**
** java cx.ath.choisnet.util.checksum.MD5CollectionXML file.xml
public static void main( String[] args ) // -------------------------------
    throws Exception
{
 File                   file    = new File( args[ 0 ] );
 java.io.StringWriter   sw      = new java.io.StringWriter();
 MD5CollectionXML instance
        = new MD5CollectionXML(
                new cx.ath.choisnet.xml.XMLParserDOM2(
                    new java.io.FileInputStream( file ),
                    false,  //  boolean validation,
                    false,  //  boolean ignoreWhitespace,
                    false,  //  boolean ignoreComments,
                    false,  //  boolean putCDATAIntoText,
                    false,  // boolean createEntityRefs,
                    new cx.ath.choisnet.xml.XMLParserErrorHandler(
                        new java.io.PrintWriter( sw )
                        )
                    )
                );

 System.out.println( "ERROR" );
 System.out.print( sw.toString() );
 System.out.println( "-----" );
 System.out.println( "INSTANCE" );
 System.out.print( MD5CollectionXML.toXML( instance ) );
 System.out.println( "-----" );
}
*/

} // class
