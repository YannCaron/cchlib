/*
** -----------------------------------------------------------------------
** Nom           : cx/ath/choisnet/util/checksum/MD5CollectionCompator.java
** Description   :
** Encodage      : ANSI
**
**  3.01.004 2006.03.02 Claude CHOISNET - Version initiale
** -----------------------------------------------------------------------
**
** cx.ath.choisnet.util.checksum.MD5CollectionCompator
**
*/
package cx.ath.choisnet.util.checksum;

import cx.ath.choisnet.util.checksum.tasks.Task;
import cx.ath.choisnet.util.checksum.tasks.TasksFactory;
import java.io.File;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

/**
** <p>
** Cette classe prend en charge la comparaison de deux {@link MD5Collection},
** elle permet défectuer des traitements défini par {@link TasksFactory}
** </p>
**
** @author Claude CHOISNET
** @since   3.01.004
** @version 3.01.009
**
** @see MD5Collection
** @see Task
** @see TasksFactory
** @deprecated use {@link cx.ath.choisnet.util.duplicate.MD5CollectionXMLException} instead
*/
@Deprecated
public class MD5CollectionCompator
{
/**
** Liste des fichiers à l'origine
*/
private MD5Collection reference;

/**
** Liste des fichiers que l'on souhaite obtenir
*/
private MD5Collection toUpdate;

/**
**
*/
private TasksFactory tasksFactory;

/**
**
*/
private LinkedList<Task> tasksList = new LinkedList<Task>();

/**
**
*/
public MD5CollectionCompator( // ------------------------------------------
    final MD5Collection referenceMD5Collection,
    final MD5Collection toUpdateMD5Collection,
    final TasksFactory  tasksFactory
    )
{
 this.reference     = referenceMD5Collection;
 this.toUpdate      = toUpdateMD5Collection;
 this.tasksFactory  = tasksFactory;
}

/**
**
*/
public void runTasks() // -------------------------------------------------
    throws cx.ath.choisnet.util.checksum.tasks.TaskFailException
{
 while( this.tasksList.size() > 0 ) {
    Task t = this.tasksList.removeFirst();

    System.out.println( "DO:" + t );

    try {
        t.doJob();
        }
    catch( cx.ath.choisnet.util.checksum.tasks.TaskRetryLaterException e ) {
        System.out.println( "***Warn: " + e.getCause() );

        //
        // On le remet pour plus tard
        //
        addTask( t );
        }
    }
}

/**
**
*/
private void addTask( final Task aTask ) // -------------------------------
{
 this.tasksList.addLast( aTask );
}

/**
**
*/
public List<Task> getTasksList() // ---------------------------------------
{
 return Collections.unmodifiableList( this.tasksList );
}

/**
**
**
*/
public void init() // -----------------------------------------------------
{
 //# ##################################################################
 //#
 //# Traitement des dossiers
 //#
 //# ##################################################################

 //
 // Dossiers à ajouter (résultat)
 //
 for( File folder : this.reference.folders() ) {
    if( ! this.toUpdate.folders().contains( folder ) ) {
        //
        // Pas trouvé, il faut créer le dossier....
        //
        addTask(
            this.tasksFactory.buildActionLocalCreateFolder( folder )
            );
        }
    }

 //
 // Dossiers à supprimer (résultat)
 //
    {
    final SortedSet<File> foldersToDelete = new TreeSet<File>( new DirComparator() );

    for( File folder : this.toUpdate.folders() ) {
        if( ! this.reference.folders().contains( folder ) ) {
            //
            // Pas trouvé, il faut supprimer le dossier....
            //
            foldersToDelete.add( folder );
            }
        }

    for( File folder : foldersToDelete ) {
        addTask(
            this.tasksFactory.buildActionLocalDeleteFolder( folder )
            );
        }
    }

 //# ##################################################################
 //#
 //# Traitement des fichiers
 //#
 //# ##################################################################

 //
 // Fichiers de références - FIXE
 //
 final Map<MD5TreeEntry,? extends Set<File>> referenceFiles = this.reference.files();

 //
 // Fichiers actuellements présents - FIXE
 //
 final Map<MD5TreeEntry,? extends Set<File>> toUpdateFiles = this.toUpdate.files();

 //
 // Recherche les fichiers supprimés (en terme d'empreintes)
 //
 for( Map.Entry<MD5TreeEntry,? extends Set<File>> toUpdate : this.toUpdate.files().entrySet() ) {
    MD5TreeEntry    md5             = toUpdate.getKey();
    Set<File>       toUpdateList    = toUpdate.getValue();
    Set<File>       refList         = referenceFiles.get( md5 );

    if( refList == null ) {
        //
        // Les fichiers associés à cette matière (md5) n'existent plus.
        //
        for( File f : toUpdateList ) {
            addTask(
                this.tasksFactory.buildActionLocalDeleteFile( f )
                );
            }
        }
    // else { on traite plus loin }
    }

 //
 // Traitement des déplacements et ajout de matière
 //

//        System.err.println( "** this.reference " + this.reference );
//        System.err.println( "** this.toUpdate " + this.toUpdate );

 for( Map.Entry<MD5TreeEntry,? extends Set<File>> refItem : referenceFiles.entrySet() ) {
    MD5TreeEntry    md5     = refItem.getKey();
    Set<File>       refList = refItem.getValue();
    Set<File>       newList = toUpdateFiles.get( md5 );

    if( newList == null ) {
        //
        // Ce fichier est dans la reference, mais pas dans la destination
        //      il récupérer la matière et créer les fichiers
        //
        addTask( this.tasksFactory.buildActionCopyFileFromSource( md5 ) );

        //
        // Création de tous les fichiers associés
        //
        for( File f : refList ) {
            addTask( this.tasksFactory.buildActionLocalCopyFile( md5, f ) );
            }
        }
    else {
        //
        // Ce fichier existe déjà dans la destination,
        // il n'y a pas besoin de récupérer la matière.
        //
        // Pour le traitement, on recherche un fichier de référance
        // correspondant à l'empreinte (qui ne bougera pas).
        //
        File currentMD5RefFile = null;

        //
        // On recherche les fichiers a supprimer
        //
        LinkedList<File> to2del  = new LinkedList<File>();

        for( File f : newList ) {
            if( ! refList.contains( f ) ) {
                to2del.add( f );
                }
            else {
                if( currentMD5RefFile == null ) {
                    currentMD5RefFile = f; // ce fichier correspond au MD5
                    }
                }
            }

        //
        // On recherche les fichiers a créer
        //
        LinkedList<File> to2create = new LinkedList<File>();

        for( File f : refList ) {
            if( ! newList.contains( f ) ) {
                to2create.add( f );
                }
            }

        //
        // Analyse des changements.
        //
        Iterator<File> to2delIter       = to2del.iterator();
        Iterator<File> to2createIter    = to2create.iterator();

        //
        // Déplacements
        //
        while( to2delIter.hasNext() && to2createIter.hasNext() ) {
            final File to2delFile       = to2delIter.next();
            final File to2createFile    = to2createIter.next();

            addTask(
                this.tasksFactory.buildActionLocalMoveFile( to2delFile, to2createFile )
                );

            if( currentMD5RefFile == null ) {
                currentMD5RefFile = to2createFile;
                }
            }

        //
        // Suppression
        //
        while( to2delIter.hasNext() ) {
            final File to2delFile = to2delIter.next();

            addTask(
                this.tasksFactory.buildActionLocalDeleteFile( to2delFile )
                );
            }

        //
        // Ajout
        //
        while( to2createIter.hasNext() ) {
            final File to2createFile = to2createIter.next(); // refFile

            addTask(
                this.tasksFactory.buildActionLocalCopyFile( currentMD5RefFile, to2createFile )
                );
            }
        }
    }

}

    /**
    **
    */
    private static class DirComparator implements Comparator<File>
    {
        /**
        **
        */
        public int compare( File o1, File o2 )
        {
            return - o1.compareTo( o2 );
        }
    };

} // class

